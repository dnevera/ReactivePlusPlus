\doxysubsection{Observers}
\hypertarget{group__observers}{}\label{group__observers}\index{Observers@{Observers}}


Observer subscribes on Observable and obtains values provided by Observable.  


\doxysubsubsubsection*{Concepts}
\begin{DoxyCompactItemize}
\item 
concept \mbox{\hyperlink{conceptrpp_1_1constraint_1_1observer__strategy}{rpp\+::constraint\+::observer\+\_\+strategy}}
\begin{DoxyCompactList}\small\item\em Concept to define strategy to override observer behavior. Strategy must be able to handle all observer\textquotesingle{}s callbacks\+: on\+\_\+next/on\+\_\+error/on\+\_\+completed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classrpp_1_1dynamic__observer}{rpp\+::dynamic\+\_\+observer$<$ Type $>$}}
\begin{DoxyCompactList}\small\item\em Type-\/erased version of the {\ttfamily \doxylink{classrpp_1_1observer}{rpp\+::observer}}. Any observer can be converted to \doxylink{classrpp_1_1dynamic__observer}{dynamic\+\_\+observer} via {\ttfamily \doxylink{classrpp_1_1observer_ab008a79c1c7825554c91dbc6d130ece4}{rpp\+::observer\+::as\+\_\+dynamic}} member function. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classrpp_1_1observer}{rpp\+::observer$<$ Type, Strategy $>$}}
\begin{DoxyCompactList}\small\item\em Base class for any observer used in RPP. It handles core callbacks of observers. Objects of this class would be passed to subscribe of observable. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$constraint\+::decayed\+\_\+type Type, std\+::invocable$<$ Type $>$ On\+Next, std\+::invocable$<$ const std\+::exception\+\_\+ptr \& $>$ On\+Error, std\+::invocable$<$$>$ On\+Completed$>$ }\\using \mbox{\hyperlink{group__observers_ga76d808086fac28fdb0b00fc7513c741a}{rpp\+::lambda\+\_\+observer}} = \mbox{\hyperlink{classrpp_1_1observer}{observer}}$<$Type, \mbox{\hyperlink{structrpp_1_1details_1_1observers_1_1lambda__strategy}{details\+::observers\+::lambda\+\_\+strategy}}$<$Type, On\+Next, On\+Error, On\+Completed$>$$>$
\begin{DoxyCompactList}\small\item\em Observer specialized with passed callbacks. Most easiesest way to construct observer "{}on the fly"{} via lambdas and etc. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$constraint\+::decayed\+\_\+type Type, std\+::invocable$<$ Type $>$ On\+Next, std\+::invocable$<$ const std\+::exception\+\_\+ptr \& $>$ On\+Error = rpp\+::utils\+::rethrow\+\_\+error\+\_\+t, std\+::invocable$<$$>$ On\+Completed = rpp\+::utils\+::empty\+\_\+function\+\_\+t$<$$>$$>$ }\\auto \mbox{\hyperlink{group__observers_gae17f62f64102925f4cd2eb29c4c27028}{rpp\+::make\+\_\+lambda\+\_\+observer}} (On\+Next \&\&on\+\_\+next, On\+Error \&\&on\+\_\+error=\{\}, On\+Completed \&\&on\+\_\+completed=\{\}) -\/$>$ \mbox{\hyperlink{group__observers_ga76d808086fac28fdb0b00fc7513c741a}{lambda\+\_\+observer}}$<$ Type, std\+::decay\+\_\+t$<$ On\+Next $>$, std\+::decay\+\_\+t$<$ On\+Error $>$, std\+::decay\+\_\+t$<$ On\+Completed $>$ $>$
\begin{DoxyCompactList}\small\item\em Constructs observer specialized with passed callbacks. Most easiesest way to construct observer "{}on the fly"{} via lambdas and etc. \end{DoxyCompactList}\item 
{\footnotesize template$<$constraint\+::decayed\+\_\+type Type, std\+::invocable$<$ Type $>$ On\+Next, std\+::invocable$<$ const std\+::exception\+\_\+ptr \& $>$ On\+Error = rpp\+::utils\+::rethrow\+\_\+error\+\_\+t, std\+::invocable$<$$>$ On\+Completed = rpp\+::utils\+::empty\+\_\+function\+\_\+t$<$$>$$>$ }\\auto \mbox{\hyperlink{group__observers_ga0a5fc7d28fa79ad482413d4f745ecc36}{rpp\+::make\+\_\+lambda\+\_\+observer}} (const \mbox{\hyperlink{group__disposables_ga310f07bbdbf66ad978e748209bfea420}{rpp\+::composite\+\_\+disposable\+\_\+wrapper}} \&d, On\+Next \&\&on\+\_\+next, On\+Error \&\&on\+\_\+error=\{\}, On\+Completed \&\&on\+\_\+completed=\{\}) -\/$>$ \mbox{\hyperlink{classrpp_1_1observer}{lambda\+\_\+observer\+\_\+with\+\_\+disposable}}$<$ Type, std\+::decay\+\_\+t$<$ On\+Next $>$, std\+::decay\+\_\+t$<$ On\+Error $>$, std\+::decay\+\_\+t$<$ On\+Completed $>$ $>$
\begin{DoxyCompactList}\small\item\em Constructs observer specialized with passed callbacks. Most easiesest way to construct observer "{}on the fly"{} via lambdas and etc. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
Observer subscribes on Observable and obtains values provided by Observable. 

Observer is kind of wrapper over 3 core functions\+:
\begin{DoxyItemize}
\item on\+\_\+next(\+T) -\/ callback with new emission provided by observable
\item on\+\_\+error(err) -\/ failure termination callback with reason of failure of observable (why observable can\textquotesingle{}t continue processing)
\item on\+\_\+completed() -\/ succeed termination callback -\/ observable is done, no any future emissions from this \begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/observable.html}{\texttt{ https\+://reactivex.\+io/documentation/observable.\+html}} 
\end{DoxySeeAlso}

\end{DoxyItemize}

\doxysubsubsection{Typedef Documentation}
\Hypertarget{group__observers_ga76d808086fac28fdb0b00fc7513c741a}\index{Observers@{Observers}!lambda\_observer@{lambda\_observer}}
\index{lambda\_observer@{lambda\_observer}!Observers@{Observers}}
\doxysubsubsubsection{\texorpdfstring{lambda\_observer}{lambda\_observer}}
{\footnotesize\ttfamily \label{group__observers_ga76d808086fac28fdb0b00fc7513c741a} 
template$<$constraint\+::decayed\+\_\+type Type, std\+::invocable$<$ Type $>$ On\+Next, std\+::invocable$<$ const std\+::exception\+\_\+ptr \& $>$ On\+Error, std\+::invocable$<$$>$ On\+Completed$>$ \\
using \mbox{\hyperlink{group__observers_ga76d808086fac28fdb0b00fc7513c741a}{rpp\+::lambda\+\_\+observer}} = \mbox{\hyperlink{classrpp_1_1observer}{observer}}$<$Type, \mbox{\hyperlink{structrpp_1_1details_1_1observers_1_1lambda__strategy}{details\+::observers\+::lambda\+\_\+strategy}}$<$Type, On\+Next, On\+Error, On\+Completed$>$$>$}



Observer specialized with passed callbacks. Most easiesest way to construct observer "{}on the fly"{} via lambdas and etc. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Type} & of value this observer can handle \\
\hline
{\em On\+Next} & is type of callback to handle on\+\_\+next(const Type\&) and on\+\_\+next(\+Type\&\&) \\
\hline
{\em On\+Error} & is type of callback to handle on\+\_\+error(const std\+::exception\+\_\+ptr\&) \\
\hline
{\em On\+Completed} & is type of callback to handle on\+\_\+completed() \\
\hline
\end{DoxyTemplParams}


\doxysubsubsection{Function Documentation}
\Hypertarget{group__observers_ga0a5fc7d28fa79ad482413d4f745ecc36}\index{Observers@{Observers}!make\_lambda\_observer@{make\_lambda\_observer}}
\index{make\_lambda\_observer@{make\_lambda\_observer}!Observers@{Observers}}
\doxysubsubsubsection{\texorpdfstring{make\_lambda\_observer()}{make\_lambda\_observer()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{group__observers_ga0a5fc7d28fa79ad482413d4f745ecc36} 
template$<$constraint\+::decayed\+\_\+type Type, std\+::invocable$<$ Type $>$ On\+Next, std\+::invocable$<$ const std\+::exception\+\_\+ptr \& $>$ On\+Error = rpp\+::utils\+::rethrow\+\_\+error\+\_\+t, std\+::invocable$<$$>$ On\+Completed = rpp\+::utils\+::empty\+\_\+function\+\_\+t$<$$>$$>$ \\
auto rpp\+::make\+\_\+lambda\+\_\+observer (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{group__disposables_ga310f07bbdbf66ad978e748209bfea420}{rpp\+::composite\+\_\+disposable\+\_\+wrapper}} \&}]{d}{, }\item[{On\+Next \&\&}]{on\+\_\+next}{, }\item[{On\+Error \&\&}]{on\+\_\+error}{ = {\ttfamily \{\}}, }\item[{On\+Completed \&\&}]{on\+\_\+completed}{ = {\ttfamily \{\}}}\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{classrpp_1_1observer}{lambda\+\_\+observer\+\_\+with\+\_\+disposable}}$<$Type,                                                                                                   std\+::decay\+\_\+t$<$On\+Next$>$,                                                                                                   std\+::decay\+\_\+t$<$On\+Error$>$,                                                                                                   std\+::decay\+\_\+t$<$On\+Completed$>$$>$}



Constructs observer specialized with passed callbacks. Most easiesest way to construct observer "{}on the fly"{} via lambdas and etc. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Type} & of value this observer can handle \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em d} & is disposable to attach to resulting observer \\
\hline
{\em on\+\_\+next} & is callback to handle on\+\_\+next(const Type\&) and on\+\_\+next(\+Type\&\&) \\
\hline
{\em on\+\_\+error} & is callback to handle on\+\_\+error(const std\+::exception\+\_\+ptr\&) \\
\hline
{\em on\+\_\+completed} & is callback to handle on\+\_\+completed() \\
\hline
\end{DoxyParams}
\Hypertarget{group__observers_gae17f62f64102925f4cd2eb29c4c27028}\index{Observers@{Observers}!make\_lambda\_observer@{make\_lambda\_observer}}
\index{make\_lambda\_observer@{make\_lambda\_observer}!Observers@{Observers}}
\doxysubsubsubsection{\texorpdfstring{make\_lambda\_observer()}{make\_lambda\_observer()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{group__observers_gae17f62f64102925f4cd2eb29c4c27028} 
template$<$constraint\+::decayed\+\_\+type Type, std\+::invocable$<$ Type $>$ On\+Next, std\+::invocable$<$ const std\+::exception\+\_\+ptr \& $>$ On\+Error = rpp\+::utils\+::rethrow\+\_\+error\+\_\+t, std\+::invocable$<$$>$ On\+Completed = rpp\+::utils\+::empty\+\_\+function\+\_\+t$<$$>$$>$ \\
auto rpp\+::make\+\_\+lambda\+\_\+observer (\begin{DoxyParamCaption}\item[{On\+Next \&\&}]{on\+\_\+next}{, }\item[{On\+Error \&\&}]{on\+\_\+error}{ = {\ttfamily \{\}}, }\item[{On\+Completed \&\&}]{on\+\_\+completed}{ = {\ttfamily \{\}}}\end{DoxyParamCaption}) -\/$>$ \mbox{\hyperlink{group__observers_ga76d808086fac28fdb0b00fc7513c741a}{lambda\+\_\+observer}}$<$Type,                                                                                   std\+::decay\+\_\+t$<$On\+Next$>$,                                                                                   std\+::decay\+\_\+t$<$On\+Error$>$,                                                                                   std\+::decay\+\_\+t$<$On\+Completed$>$$>$}



Constructs observer specialized with passed callbacks. Most easiesest way to construct observer "{}on the fly"{} via lambdas and etc. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Type} & of value this observer can handle \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em on\+\_\+next} & is callback to handle on\+\_\+next(const Type\&) and on\+\_\+next(\+Type\&\&) \\
\hline
{\em on\+\_\+error} & is callback to handle on\+\_\+error(const std\+::exception\+\_\+ptr\&) \\
\hline
{\em on\+\_\+completed} & is callback to handle on\+\_\+completed() \\
\hline
\end{DoxyParams}
